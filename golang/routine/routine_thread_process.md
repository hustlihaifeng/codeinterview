[TOC]



# 1. 协程、线程、进程的区别

1. 进程和线程都是有操作系统调度的，协程是由用户态程序调度的。golang的协程是由用户态的go runtime调度的。
2. 进程有自己独立的虚拟内存空间，有独立的堆、栈、代码段、打开的文件。
3. 线程有自己独立的栈空间，其他的堆、代码段、数据段、打开的文件、信号等进程级别的资源都与同一进程里面的其他线程共享（共享虚拟内存空间）。所以多线程可以直接用全局变量通信。线程只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)。
4. 协程和线程一样共享堆，不共享栈。区别是协程有用户态的协程运行时调度。
5. 另外一个可执行程序可以fork处多个子进程。子进程和父进程是独立的。
   1. 父进程先与子进程退出，子进程变成孤儿进程。孤儿进程有进程号为1的进程接管。
   2. 子进程先与父进程退出，父进程却没有调用**wait或waitpid获取子进程的状态信息**，那么子进程**的进程描述符仍然保存在系统中**，称之为僵尸进程（已经结束了，但是还留下了来继续存在的部分）。**其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。**

## 1.2 为什么协程比线程的并发度高

1. 执行协程只需要极少的栈内存（大概是4～5KB），默认情况下，线程栈的大小为1MB。
2. 参考[Go goroutine理解](<https://zhuanlan.zhihu.com/p/60613088>)：

> ## Goroutine 小结
>
> 优点：
>
> 1、开销小
>
> POSIX的thread API虽然能够提供丰富的API，例如配置自己的CPU亲和性，申请资源等等，线程在得到了很多与进程相同的控制权的同时，开销也非常的大，在Goroutine中则不需这些额外的开销，所以一个Golang的程序中可以支持10w级别的Goroutine。
>
> 每个 goroutine (协程) 默认占用内存远比 Java 、C 的线程少（*goroutine：*2KB ，线程：8MB）
>
> 2、调度性能好
>
> 在Golang的程序中，操作系统级别的线程调度，通常不会做出合适的调度决策。例如在GC时，内存必须要达到一个一致的状态。在Goroutine机制里，Golang可以控制Goroutine的调度，从而在一个合适的时间进行GC。
>
> 在应用层模拟的线程，它避免了上下文切换的额外耗费，兼顾了多线程的优点。简化了高并发程序的复杂度。
>
> 缺点：
>
> 协程调度机制无法实现公平调度

# 2. golang的GMP模型

1. 详见：[Go并发调度器解析之实现一个高性能协程池](<https://zhuanlan.zhihu.com/p/37754274>)



# 参考资料

1. [golang协程为什么比线程轻量？](<https://www.ctolib.com/topics-141846.html>)
2. [孤儿进程与僵尸进程总结](https://www.cnblogs.com/Anker/p/3271773.html)
3. [Go并发调度器解析之实现一个高性能协程池](<https://zhuanlan.zhihu.com/p/37754274>)