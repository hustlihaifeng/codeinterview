# 目录
- [算法分析](#算法分析)
- [快慢指针检查环形链表代码](#快慢指针检查环形链表代码)
- [附录](#附录)
    - [1. 快慢指针检查环形链表完整代码](##1.-快慢指针检查环形链表完整代码)
# 算法分析
1. 将每个节点是否被访问过存入map，如果新访问一个已经被访问的节点，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(n)`，n是链表节点个数。
2. 使用快慢指针，如果快指针追上慢指针，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(1)`，n是链表节点个数。
    - 难点：快指针有可能跳过慢指针，导致碰撞不了
    - 解决办法：对于一个一次移动两步的快指针`p2`，每次同时将`p2`和`p2->Next`与慢指针`p1`比较，就可以避免跳过的情况。

# 快慢指针检查环形链表代码
```go
func isCyclicList(l *list.List) bool {

	for p1, p2 := l.Front, l.Front; p2 != nil && p1 != nil; p1, p2 = p1.Next, p2.Next {
		p2 = p2.Next
		if p2 == nil {
			break
		}

		if p2 == p1 || p2.Next == p1 { // p1 != nil
			return true
		}
	}

	return false
}
```

# 附录
## 1. 快慢指针检查环形链表完整代码
- [main.go](main.go): 关键函数`isCyclicList`，和测试函数`main`

- [in.go](../in.go) : 提供各种`*List`的测试链表

- [list.go](../list.go): 定义双向链表和常见操作(本来可以使用go的list包的，但是用go的list包不知道怎么构建环形链表，就自己实现了双向链表结构)
