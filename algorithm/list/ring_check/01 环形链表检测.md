# 目录
- [算法分析](#算法分析)
- [快慢指针检查环形链表代码](#快慢指针检查环形链表代码)
- [附录](#附录)
    - [1. 快慢指针检查环形链表完整代码](#1-快慢指针检查环形链表完整代码)
# 算法分析
1. 将每个节点是否被访问过存入map，如果新访问一个已经被访问的节点，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(n)`，n是链表节点个数。
2. 使用快慢指针，如果快指针追上慢指针，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(1)`，n是链表节点个数。
    - 难点：快指针有可能跳过慢指针，导致碰撞不了
    - 解决办法：快指针追慢指针过程中，两者距离每次减少两者速度差个单位。那么让两者速度差为1，如果有环，则两者一定能相遇。
3. 如何找环点

	假设慢指针目前在环点，根据上面分析的每走一步两者距离减1，假设环长度为r，那么最多需要r-1步，快慢指针就能相遇。也即最多n步，两者就能相遇。

	设相遇时慢指针走了k步，那么k+mr=2k，mr=k。由于k是r整数倍，那么再走k步的话，一定能回到当前点。这样在相遇点，让两个指针的速度都变为1，一个从当前相遇点开始走，一个从链表起始点开始走，两者在k步后一定都能在当前点相遇。由于两者步速相同，那么从环点到当前点的这段路程，两者是重合的，那么两者一定会在环点相遇。

# 附录
## 1. 快慢指针检查环形链表完整代码，最初的不好的实现。关键在于如何相遇这个问题没想清楚
- [main.go](main.go): 关键函数`isCyclicList`，和测试函数`main`

- [in.go](../in.go) : 提供各种`*List`的测试链表

- [list.go](../list.go): 定义双向链表和常见操作(本来可以使用go的list包的，但是用go的list包不知道怎么构建环形链表，就自己实现了双向链表结构)

## 2. 检测环和找环点代码，好的实现
- [ringpoint.go](ringpoint.go)
