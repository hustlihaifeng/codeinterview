# 目录
- [算法分析](# 算法分析)
# 算法分析
1. 将每个节点是否被访问过存入map，如果新访问一个已经被访问的节点，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(n)`，n是链表节点个数。
2. 使用快慢指针，如果快指针追上慢指针，说明是环形链表。时间复杂度`O(n)`，空间复杂度`O(1)`，n是链表节点个数。
    - 难点：快指针有可能跳过慢指针，导致碰撞不了
    - 解决办法：对于一个一次移动两步的快指针`p2`，每次同时将`p2`和`p2->Next`与慢指针`p1`比较，就可以避免跳过的情况。

# 快慢指针检查环形链表代码
```go
func isCyclicList(l *list.List) bool {

	for p1, p2 := l.Front, l.Front; p2 != nil && p1 != nil; p1, p2 = p1.Next, p2.Next {
		p2 = p2.Next
		if p2 == nil {
			break
		}

		if p2 == p1 || p2.Next == p1 { // p1 != nil
			return true
		}
	}

	return false
}
```

# 附录
## 1. 快慢指针检查环形链表完整代码
- `main.go`: 关键函数`isCyclicList`，和测试函数`main`
```
package main

import (
	"fmt"
	"lhf/leetcode/list"
)

func main() {
	fmt.Printf("%v is cyclic list ? %v\n", "NilList", isCyclicList(list.NilList))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList1", isCyclicList(list.CyclicList1))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList2", isCyclicList(list.CyclicList2))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList3", isCyclicList(list.CyclicList3))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList4", isCyclicList(list.CyclicList4))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList5", isCyclicList(list.CyclicList5))
	fmt.Printf("%v is cyclic list ? %v\n", "CyclicList6", isCyclicList(list.CyclicList6))
	fmt.Printf("%v is cyclic list ? %v\n", "LineList1", isCyclicList(list.LineList1))
	fmt.Printf("%v is cyclic list ? %v\n", "LineList2", isCyclicList(list.LineList2))
	fmt.Printf("%v is cyclic list ? %v\n", "LineList6", isCyclicList(list.LineList6))
}

func isCyclicList(l *list.List) bool {

	for p1, p2 := l.Front, l.Front; p2 != nil && p1 != nil; p1, p2 = p1.Next, p2.Next {
		p2 = p2.Next
		if p2 == nil {
			break
		}

		if p2 == p1 || p2.Next == p1 { // p1 != nil
			return true
		}
	}

	return false
}

```

- `in.go` : 提供各种`*List`的测试链表
```go
package list

var NilList = NewList()
var CyclicList1 = NewCyclicList(6, 1)
var CyclicList2 = NewCyclicList(6, 2)
var CyclicList3 = NewCyclicList(6, 3)
var CyclicList4 = NewCyclicList(6, 4)
var CyclicList5 = NewCyclicList(6, 5)
var CyclicList6 = NewCyclicList(6, 6)
var LineList1 = NewLineList(1)
var LineList2 = NewLineList(2)
var LineList6 = NewLineList(6)

func NewCyclicList(total, cyclicPoint int) *List {
	lst := NewList()
	var cyclicElem *Elem
	for i := 1; i <= total; i++ {
		e := lst.PushBack(i)
		if i == cyclicPoint {
			cyclicElem = e
		}
	}
	lst.Back.Next = cyclicElem

	return lst
}

func NewLineList(num int) *List {
	lst := NewList()
	for i := 1; i <= num; i++ {
		lst.PushBack(i)
	}

	return lst
}

```
- `list.go`: 定义双向链表和常见操作(本来可以使用go的list包的，但是用go的list包不知道怎么构建环形链表，就自己实现了双向链表结构)
```
package list

type List struct {
	Front *Elem
	Back  *Elem
}
type Elem struct {
	Value interface{}
	Next  *Elem
	Prev  *Elem
}

func NewList() *List {
	return &List{}
}

func (s *List) PushBack(val interface{}) *Elem {
	e := &Elem{Value: val}
	e.Next = nil
	if s.Front == nil {
		s.Front = e
		e.Prev = nil
	} else {
		s.Back.Next = e
		e.Prev = s.Back
	}

	s.Back = e

	return e
}

func (s *List) Remove(e *Elem) interface{} {
	for pe := s.Front; pe != nil; pe = pe.Next {
		if pe == e {
			if pe == s.Front {
				if s.Front == s.Back {
					s.Front = nil
					s.Back = nil
				} else {
					s.Front = s.Front.Next
					if s.Front != nil {
						s.Front.Prev = nil
					}
				}
			} else if pe == s.Back {
				s.Back = s.Back.Prev
				if s.Back != nil {
					s.Back.Next = nil
				}
			} else {
				prev := pe.Prev
				next := pe.Next
				prev.Next = next
				next.Prev = prev
			}

			return pe.Value
		}
	}

	return nil
}

```
