[TOC]

# 问题1：计算一个对象存储空间
1. 答案：非静态成员变量总和+数据对齐（编译器为cpu计算所做的）+支持虚函数所产生的负担
eg1：`class Empty{};`
2. 必须有一定的空间，c++中为1byte。总结如下：
- 空类占用1byte
- 非静态变量占用空间（如short的还要考虑数据对齐）
- static变量不占用空间
- 成员函数不占用空间
- 构造函数和析构函数不占用空间
- 支持虚函数的虚表指针的空间（包括:`public virtual A`这样的形式）
# 问题2：this指针指向的是啥
this指针是指向本类对象的指针。**编译器实际将a.func()变为了a.func(&a)，其中&a被赋值给了this指针**。调用a的成员函数f，实际上是在调用f时使this指向对象a，从而访问a的成员。
- this指针只能在成员函数中使用。在全局函数、静态函数中不能使用。
- this指针在成员函数开始前构造，在成员函数结束时清除。
- this会因为编译器不同而有不同的存储位置，可能是栈、寄存器或全局变量
- this指针在成员函数中才有定义，避免在构造函数中使用this指针。
	- 调用非静态成员函数需要this指针，所以尽量不要在构造函数里面调用非静态成员函数
# 问题3：类模板如何使用
1. 先写一个实际的类
2. 将此类中准备改变的类型名替换成虚拟类型名，如T
3. 在类声明前加一行：`template<class 虚拟类型名>`
4. 类模板使用：
```cpp
类模板名 <实际类型名> 对象名；
类模板名 <实际类型名> 对象名(实参列表)；
```
5. 类模板外定义成员函数，应该用类模板的形式：
```cpp
template <class 虚拟类型名>
返回值类型 类模板名<虚拟类型名>::成员函数名(函数参数列表){...}
```
6. 打印函数模版：
```cpp
template <class T>
class PrintArray{
public:
        void print(T *array,unsigned len){
                for(int i=0;i<len;i++){
                        cout<<array[i]<<" ";
                }
                cout<<endl;
        }
};
PrintArray<double> doubleprinter;
doubleprinter.print(doublearray,n);
```
# 问题4：构造函数和析构函数的调用时机
1. **构造函数按照对象声明先后依次调用，析构函数与构造函数调用顺序相反**（类似于一个栈，后进先出）
2. **全局对象和static对象的析构函数在main结束或者调用exit时才被调用**。局部非静态对象作用域结束后就调用析构函数。
3. **全局对象（函数之外）的构造函数在文件中的所有函数执行之前被调用**。同一个程序中的多个文件里面的全局对象的构造函数调用先后不确定。**静态局部变量的构造函数在第一次调用函数时被调用一次**。
# 问题5：派生类的访问属性
1. 派生类的访问属性限制了一个最高的访问属性，基类成员本身可见性和派生类访问属性中小的一个即决定在子类中的可见性。
# 问题6：派生类如何初始化基类
**基类对象必须通过参数列表初始化**，子类对象还可以在构造函数内初始化。构造函数调用顺序为**基类构造函数-》子类对象的构造函数-》派生类的的构造函数体**。**派生类只负责其直接父类的初始化**。
如：
```cpp
class B:public A{
public:
    B(a,b,c,_d,_e):A(a,b,c),d(_d),e(_e){

    }
private:
    d,e;
}
```
# 问题7：派生类的构造函数和析构函数调用顺序
1. 构造函数调用顺序如下：**同级多个按声明顺序初始化，与初始化列表中的顺序无关**。
- 先是基类构造函数。如果有多个基类，则**按照派生**时出现的**顺序**依次调用，**而不是**他们在**初始化表中的顺序**。
- 然后是类成员对象构造函数。如果有多个类成员对象，按照对象声明的顺序，而不是他们在初始化表中的顺序。
- 最后是派生类构造函数。
2. 析构函数调用顺序与上面的构造函数顺序刚好相反。
# 问题8：多态是指什么意思
1. 多态性指具有不同功能的函数可以用同一个函数名，这样就可以用同一个函数名调用不同内容的函数。对同一个消息，不同对象有不同的响应。**多态通过虚函数来实现**。
2. 当把基类的某个成员函数前面加上virtual关键字后，该函数成为虚函数。虚函数可以在派生类中重新定义。可以通过给基类对象指针赋不同的派生类对象，然后用该指针调用基类虚函数，实现对该函数不同实现的调用。（基类指针调用不同派生类对某个函数的实现，即为多态）
3. c++中，如果基类某个函数是虚函数。则派生类中的同名函数自动成为虚函数，不管加没加virtual关键字（但加上virtual关键字能使程序更加清晰）。
4. 当一个类中有虚函数时，编译器会自动为该类构造一个虚函数表，它是一个指针数组，用于存放每个虚函数的入口地址。
5. 虚函数：`virtual fuction();`	纯虚函数：`virtual function()=0;`纯虚函数派生类必须实现。含有纯虚函数的类为抽象类，不能实例化，但可以声明抽象类指针。
6. **构造函数不能是虚函数（在构造函数前，对象不存在，不能通过指针访问构造函数）。析构函数最好声明为虚函数，不然有可能造成派生类的资源释不能得到释放，造成memory leap（因为不能通过指针访问派生类的析构函数）。所以析构函数前加上virtual。**
# 总结
继承是在重构时用到的，而不是在程序设计之初就使用继承。**最开始优先使用组合，而不是继承。**
