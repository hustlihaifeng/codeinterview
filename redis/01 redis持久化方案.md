# 内容
- [1 持久化方式及对比](#1-持久化方式及对比)
- [2 持久化配置](#2-持久化配置)
	- [2.1 RDB配置](#2.1-RDB配置)
	- [2.2 AOF配置](#2.2-AOF配置)
- [3 实现原理](#3-实现原理)
	- [3.1 RDB备份原理](#3.1-RDB备份原理)
	- [3.2 AOF备份原理](#3.2-AOF备份原理)
		- [3.2.1 AOF重写机制](#3.2.1-AOF重写机制)
- [参考资料](#参考资料)

# 1 持久化方式及对比
1. 有RDB（Redis DataBase）和AOF（Append Only File）两种持久化/备份 方式。两者对比如下
|对比项|RDB|AOF|
|-|-|-|
|全称|Redis DataBase|Append Only File|
|备份方式|拷贝数据文件的物理备份|记录更新操作的逻辑备份|
|运行方式|定期拷贝和写磁盘|后台定期或持续 收集增量更新，写磁盘|
|备份速度|相对慢，需要一次拷贝所有数据|只append增量更新|
|备份时对业务访问的影响|有影响，会导致服务暂停，有可能达到1秒|append更新，基本无影响|
|恢复速度|快，直接拉起|慢，需要将所有更新重新应用一遍|
|是否会丢数据|会，备份间隔里的数据就会丢失，且由于全量拷贝时阻塞访问，不能备份太频繁|会，备份间隔数据会丢失，但这个间隔可以配的比较小，比如1s|
|默认备份文件名|当前目录下的dump.rdb|当前工作目录的appendonly.aof|

2. 两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。
# 2 持久化配置
## 2.1 RDB配置
- RDB路径和文件名
```
# RDB文件名，默认为dump.rdb。
dbfilename dump.rdb

# 文件存放的目录，AOF文件同样存放在此目录下。默认为当前工作目录。
dir ./
```

- 备份间隔
```
格式为：save <seconds> <changes>
save 900 1 #900秒后至少1个key有变动就备份
save 300 10 #300秒后至少10个key有变动就备份
save 60 10000 #60秒后至少10000个key有变动就备份
# 禁用RDB备份
save ""
```
- 错误处理:  默认情况下，如果Redis在后台生成快照的时候失败，那么就会停止接收数据，目的是让用户能知道数据没有持久化成功。但是如果你有其他的方式可以监控到Redis及其持久化的状态，那么可以把这个功能禁止掉。
```
stop-writes-on-bgsave-error yes
```
- 数据压缩: 默认Redis会采用LZF对数据进行压缩。如果你想节省点CPU的性能，你可以把压缩功能禁用掉，但是数据集就会比没压缩的时候要大
```
rdbcompression yes
```
- 数据校验： 从版本5的RDB的开始，一个CRC64的校验码会放在文件的末尾。这样更能保证文件的完整性，但是在保存或者加载文件时会损失一定的性能（大概10%）。如果想追求更高的性能，可以把它禁用掉，这样文件在写入校验码时会用0替代，加载的时候看到0就会直接跳过校验。
```
rdbchecksum yes
```
## 2.2 AOF配置
- 文件路径和名称
```
# 文件存放目录，与RDB共用。默认为当前工作目录。
dir ./

# 默认文件名为appendonly.aof
appendfilename "appendonly.aof"
```
- 备份间隔
	- always: 每当有新命令追加到AOF的时候调用fsync。速度最慢，但是最安全。
	- everysec: 每秒fsync一次。速度快（2.4版本跟快照方式速度差不多），安全性不错（最多丢失1秒的数据）。
	- no: 从不fsync，交由系统去处理。这个方式速度最快，但是安全性一般。
	- 推荐使用每秒fsync一次的方式（默认的方式），因为它速度快，安全性也不错
```
# appendfsync always
appendfsync everysec # 默认的方式
# appendfsync no
```
- 日志重写: 
	- Redis 2.4以上才可以自动进行日志重写，之前的版本需要手动运行BGREWRITEAOF这个命令。
```
# Redis会记住自从上一次重写后AOF文件的大小（如果自Redis启动后还没重写过，则记住启动时使用的AOF文件的大小）。
# 如果当前的文件大小比起记住的那个大小超过指定的百分比，则会触发重写。
# 同时需要设置一个文件大小最小值，只有大于这个值文件才会重写，以防文件很小，但是已经达到百分比的情况。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 要禁用自动的日志重写功能，我们可以把百分比设置为0：
# auto-aof-rewrite-percentage 0
```
# 3 实现原理
## 3.1 RDB备份原理
1. 备份流程
- Redis调用fork()，产生一个子进程。
- 子进程把数据写到一个临时的RDB文件。
- 当子进程写完新的RDB文件后，把上次的RDB文件替换掉。
2. 如何处理拷贝时的并发问题？ 阻塞其他操作，拷贝数据
3. 为什么需要fork进程？ 备份分为拷贝和写磁盘两步。拷贝是写内存，很快；写磁盘就比较慢了。所以利用fork时拷贝内存里的数据（每个进程独占内存等资源），然后在没有业务访问的子进程里面进行比较慢的写磁盘操作，来尽量减小对正常访问的阻塞。如果不fork直接在当前进程进行拷贝，那么比较慢的写磁盘操作也会阻塞正常访问。
- Redis提供了两个命令save、bgsave用于手动生成快照，save不fork子进程，写磁盘时也会阻塞访问；bgsave会fork子进程，只在fork时阻塞访问。
- 至少要预留一般的内存空间给子进程，且为了避免fork阻塞时间过长，redis单个实例数据量不能太大。

## 3.2 AOF备份原理
### 3.2.1 AOF重写机制

aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用incr test命令100次，文件中必须保存全部的100条命令，其实有99条都是多余的。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。

为了压缩aof的持久化文件。redis提供了`bgrewriteaof`命令。收到此命令redis将使用与快照类似的方式将内存中的数据 以命令的方式保存到临时文件中，最后替换原来的文件。具体过程如下:
- redis调用fork ，现在有父子两个进程
- 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
- 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
- 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
- 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。

需要注意到是重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件,这点和快照有点类似。

# 参考资料
- [Redis持久化](https://segmentfault.com/a/1190000002906345)  有快照读（RDB）和追加式文件（AOF）两种持久化方式。RDB里面直接就是数据（物理备份），AOF里面是更新语句（逻辑备份）。可以禁用，也可以同时存在（redis启动是，AOF数据会被优先用于重建数据）。
- [Redis持久化机制原理分析与解惑-为什么Redis进行RDB持久化数据时，新起一个进程而不是在原进程中起一个线程](https://blog.csdn.net/u011784767/article/details/76824822) 解释了RDB快照应对并发问题的原理：redis进程进行快照时，需要阻塞写操作，否则会与并发问题；持久化需要写磁盘，写内存比写磁盘块很多，所以redis采用先阻塞的将数据拷贝到临时内存中，然后将这个临时内存中的数据落地到存盘的方式来提高新能（fork子进程来写磁盘）。